// Cambia la URL por la de tu backend Node.js desplegado (por ejemplo, Railway, Render, Heroku)const socket = io('https://TU_BACKEND_URL');// --- Login/Register Logic (igual que antes, localStorage) ---const loginSection = document.getElementById('login-section');const registerSection = document.getElementById('register-section');const streamerPanel = document.getElementById('streamer-panel');const viewerPanel = document.getElementById('viewer-panel');const loginForm = document.getElementById('loginForm');const registerForm = document.getElementById('registerForm');const loginMsg = document.getElementById('loginMsg');const registerMsg = document.getElementById('registerMsg');const showRegister = document.getElementById('showRegister');const showLogin = document.getElementById('showLogin');let isStreamer = false;let username = null;function getUsers() {    return JSON.parse(localStorage.getItem('users') || '{}');}function saveUser(username, password) {    const users = getUsers();    users[username.toLowerCase()] = password;    localStorage.setItem('users', JSON.stringify(users));}function userExists(username) {    const users = getUsers();    return !!users[username.toLowerCase()];}function checkUser(username, password) {    const users = getUsers();    return users[username.toLowerCase()] === password;}showRegister.addEventListener('click', e => {    e.preventDefault();    loginSection.classList.add('hidden');    registerSection.classList.remove('hidden');    loginMsg.textContent = '';});showLogin.addEventListener('click', e => {    e.preventDefault();    registerSection.classList.add('hidden');    loginSection.classList.remove('hidden');    registerMsg.textContent = '';});registerForm.addEventListener('submit', function(e) {    e.preventDefault();    const u = document.getElementById('regUsername').value.trim();    const p = document.getElementById('regPassword').value.trim();    if (!u || !p) {        registerMsg.textContent = 'Completa todos los campos.';        return;    }    if (userExists(u)) {        registerMsg.textContent = 'El usuario ya existe.';        return;    }    saveUser(u, p);    registerMsg.textContent = '¡Registro exitoso! Ahora inicia sesión.';    setTimeout(() => {        registerSection.classList.add('hidden');        loginSection.classList.remove('hidden');        registerMsg.textContent = '';    }, 1200);});loginForm.addEventListener('submit', function(e) {    e.preventDefault();    username = document.getElementById('username').value.trim();    const password = document.getElementById('password').value.trim();    if (!checkUser(username, password)) {        loginMsg.textContent = 'Usuario o contraseña incorrectos.';        return;    }    loginMsg.textContent = '';    loginSection.classList.add('hidden');    registerSection.classList.add('hidden');    isStreamer = username.toLowerCase() === 'denizze';    if (isStreamer) {        streamerPanel.classList.remove('hidden');    } else {        viewerPanel.classList.remove('hidden');    }    socket.emit('login', username);});// --- WebRTC + Socket.io ---let peerConnections = {};let localStream = null;const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };// STREAMERconst startCamBtn = document.getElementById('startCam');const videoPreview = document.getElementById('videoPreview');const goLiveBtn = document.getElementById('goLive');if (startCamBtn && videoPreview) {    startCamBtn.addEventListener('click', async () => {        try {            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });            videoPreview.srcObject = localStream;        } catch (err) {            alert('No se pudo acceder a la cámara: ' + err.message);        }    });}if (goLiveBtn) {    goLiveBtn.addEventListener('click', () => {        if (!localStream) {            alert('Primero debes iniciar la cámara.');            return;        }        // Espera a que los viewers se conecten (socket.io)    });}// Cuando un viewer se conectasocket.on('watcher', id => {    if (!isStreamer || !localStream) return;    const peerConnection = new RTCPeerConnection(config);    peerConnections[id] = peerConnection;    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));    peerConnection.onicecandidate = event => {        if (event.candidate) {            socket.emit('candidate', id, event.candidate);        }    };    peerConnection.createOffer().then(sdp => {        peerConnection.setLocalDescription(sdp);        socket.emit('offer', id, sdp);    });});socket.on('answer', (id, description) => {    peerConnections[id].setRemoteDescription(description);});socket.on('candidate', (id, candidate) => {    peerConnections[id].addIceCandidate(new RTCIceCandidate(candidate));});socket.on('disconnectPeer', id => {    if (peerConnections[id]) {        peerConnections[id].close();        delete peerConnections[id];    }});// VIEWERconst liveVideo = document.getElementById('liveVideo');if (liveVideo) {    socket.emit('watcher');}let viewerPC = null;socket.on('offer', (id, description) => {    viewerPC = new RTCPeerConnection(config);    viewerPC.ontrack = event => {        liveVideo.srcObject = event.streams[0];    };    viewerPC.onicecandidate = event => {        if (event.candidate) {            socket.emit('candidate', id, event.candidate);        }    };    viewerPC.setRemoteDescription(description).then(() => {        return viewerPC.createAnswer();    }).then(sdp => {        viewerPC.setLocalDescription(sdp);        socket.emit('answer', id, sdp);    });});socket.on('candidate', (id, candidate) => {    if (viewerPC) viewerPC.addIceCandidate(new RTCIceCandidate(candidate));});socket.on('disconnectPeer', () => {    if (viewerPC) viewerPC.close();});// --- Chat en tiempo real ---const chatForm = document.getElementById('chatForm');const chatInput = document.getElementById('chatInput');const chatMessages = document.getElementById('chatMessages');const emotes = document.querySelectorAll('.emote');if (chatForm && chatInput && chatMessages) {    chatForm.addEventListener('submit', function(e) {        e.preventDefault();        const msg = chatInput.value.trim();        if (msg) {            socket.emit('chat', msg);            chatInput.value = '';        }    });    emotes.forEach(emote => {        emote.addEventListener('click', () => {            chatInput.value += emote.textContent;            chatInput.focus();        });    });}socket.on('chat', ({ user, msg }) => {    const div = document.createElement('div');    div.className = 'chat-msg';    div.innerHTML = `<span class=\"chat-user\">${user}:</span> <span class=\"chat-text\">${msg}</span>`;    chatMessages.appendChild(div);    chatMessages.scrollTop = chatMessages.scrollHeight;});